### js中参数传递
- javascript 总是按值传递，但是当变量引用对象时，"值"是对对象的引用；
- 更改变量的值不会改变底层原始数据或对象，只是改变了数据或指向了另一个对象；
- 改变变量引用对象的一个属性会改变底层对象

### 类数组对象与arguments
- Arguments对象：Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。
- callee属性：可以调用函数自身，arguments.callee.xxx
- arguments和对应参数绑定
  - 非严格模式下，传入的参数，实参和arguments的值会共享，当没有传入时，实参是不会跟arguments值共享的；
  - 严格模式下，实参和arguments是不会共享的
- 应用：参数不定长、函数科里化、递归调用、函数重载

### 执行上下文
- 执行上下文是评估和执行javaScript代码的环境的抽象概念
- 执行上下文类型：
  - 全局上下文： 任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的window对象(浏览器的情况下)，并且设置this的值等于这个全局对象
  - 函数上下文： 每一个函数被调用时都会创建一个新的上下文。
  - eval上下文
- 执行上下文中三个重要属性
  - this绑定
  - 作用域链：当查找变量时会先从当前上下文的变量对象中查找，如果没找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就是作用域链
  - 变量对象
- 词法作用域：一个函数可以访问在它的调用上下文中定义的变量

```js
function setFirstName(firstName) {
  return function(lastName) {
    return firstName + lastName
  }
}

var setLastName = setFirstName('feng')
setLastName('na')
// 解析：调用setFirstName时返回一个匿名函数，该匿名函数会持有setFirstName函数作用域的变量对象(arguments,firstName)
// setFirstName函数执行完之后其执行环境被销毁，但是他的变量对象会一直保存在内存中不被销毁。
// 同样垃圾回收机制因为变量对象会被一直hold而不做回收处理。内存泄露需要手动释放内存处理。
setLastName = null
```

### 闭包
- 闭包是指那些能访问自由变量的函数
- 自由变量指既不是参数也不是函数局部变量的变量
- 函数对象被调用时 会创建一个新的执行上下文，函数对象里面的[[scope]]属性保存着该函数定义的时候能直接访问的作用域对象
- 闭包什么时候被创建？所有js对象都是闭包，因此当定义一个函数时就定义了一个 闭包
- 闭包什么时候被销毁？当它不被任何其他对象引用的时候

### 实例、原型指针_proto_、原型 prototype
- 原型：每一个javascript对象(null除外)在创建时就会与之关联另一个对象，这个对象就是我们说的原型，每个对象都会从原型 "继承" 属性
- 原型链： 由多个_proto_构成的相互关联的原型组成的链状结构的就是原型链
- 并非是真的继承，继承意味着复制操作，这里并没有复制对象的属性，只是在两个对象之间创建一个关联，这样一个对象能通过委托访问到另一个对象的属性和函数，与其叫继承，委托的叫法更准确些
- 总结：函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现“继承”，还有一个原型指针__proto__，该指针指向上一层的原型对象，而上一层的原型对象的结构类似，这样利用__proto__一直指向Object的原型对象上，而Object的原型对象用Object.prototype.__proto__ = null表示原型链的最顶端，如此形成了js的原型链继承，也解释了为什么所有的js对象都具有Object的基本方法。

```js
Function.prototype = {
    constructor: Function,
    __proto__:parent.prototype,
    some prototype prototies...
}
```

### this 指向
- this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
- 优先级
  1. 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。
      var bar = new foo()
  2. 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。
      var bar = foo.call(obj2)
  3. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。
      var bar = obj1.foo()
  4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。
      var bar = foo()
