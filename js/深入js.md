### js中参数传递
- javascript 总是按值传递，但是当变量引用对象时，"值"是对对象的引用；
- 更改变量的值不会改变底层原始数据或对象，只是改变了数据或指向了另一个对象；
- 改变变量引用对象的一个属性会改变底层对象

### 数据的存储
- 基本数据类型变量值存储在栈中
- 对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程
- 栈优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享；
- 栈缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

### 类数组对象arguments
- Arguments对象：Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。
- callee属性：可以调用函数自身，arguments.callee.xxx
- arguments和对应参数绑定
  - 非严格模式下，传入的参数，实参和arguments的值会共享，当没有传入时，实参是不会跟arguments值共享的；
  - 严格模式下，实参和arguments是不会共享的
- 应用：参数不定长、函数柯里化、递归调用、函数重载

### 调用栈

### JS代码运行
- 分编译阶段、真正代码执行阶段，变量声明、函数声明等都是在编译阶段
- 编译阶段：创建当前上下文，var声明的变量放在变量环境里，let声明的变量放在词法环境里
- 变量声明：创建-> 初始化 -> 赋值 三阶段
  - var创建的时候就初始化了，有值则赋值，没有则是undefined；
  - let/const 会被先创建，但是不会被初始化，直到声明语句被执行的时候，let初始化的时候如果没有赋值，则执行时就是undefined，创建阶段到初始化阶段的代码片段就形成了`暂时性死区`，在这期间访问的话会报错；
  - const初始化的时候必须赋值，否则报错，如果声明的是一个`引用类型`，则不能改变它的内存地址

### 作用域
- 释义：作用域指程序中定义变量的区域，该位置决定了变量的生命周期；作用域就是变量与函数的可访问范围，即作用域控制变量和函数的可见性和生命周期
- 分类：
  - 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
  - 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。
  - 块级作用域(ES6新增)：作用块内声明的变量不影响块外面的变量


### 作用域链
- 通过作用域查找变量的链条称为作用域链，作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。

### 词法作用域
- 词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符

### 执行上下文
- 执行上下文是评估和执行javaScript代码的环境的抽象概念
- 调用栈（执行上下文栈）：在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈
- 执行上下文类型：
  - 全局上下文： 任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的window对象(浏览器的情况下)，并且设置this的值等于这个全局对象
  - 函数上下文： 每一个函数被调用时都会创建一个新的上下文。
  - eval上下文
- 执行上下文中三个重要属性
  - this绑定
  - 作用域链：当查找变量时会先从当前上下文的变量对象中查找，如果没找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就是作用域链
  - 变量对象
- 词法作用域：一个函数可以访问在它的调用上下文中定义的变量

```js
function setFirstName(firstName) {
  return function(lastName) {
    return firstName + lastName
  }
}

var setLastName = setFirstName('feng')
setLastName('na')
// 解析：调用setFirstName时返回一个匿名函数，该匿名函数会持有setFirstName函数作用域的变量对象(arguments,firstName)
// setFirstName函数执行完之后其执行环境被销毁，但是他的变量对象会一直保存在内存中不被销毁。
// 同样垃圾回收机制因为变量对象会被一直hold而不做回收处理。内存泄露需要手动释放内存处理。
setLastName = null
```

### 闭包
- 闭包是指那些能访问自由变量的函数 --- 详解：在javascript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中的声明的变量，当通过调用一个外部函数返回一个内部函数后，即该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，这些变量的集合就是闭包
- 自由变量指既不是参数也不是函数局部变量的变量
- 函数对象被调用时 会创建一个新的执行上下文，函数对象里面的[[scope]]属性保存着该函数定义的时候能直接访问的作用域对象
- 闭包什么时候被创建？所有js对象都是闭包，因此当定义一个函数时就定义了一个 闭包
- 闭包什么时候被销毁？当它不被任何其他对象引用的时候

### 实例、原型指针_proto_、原型 prototype
- 原型：每一个javascript对象(null除外)在创建时就会与之关联另一个对象，这个对象就是我们说的原型，每个对象都会从原型 "继承" 属性
- 原型链： 由多个_proto_构成的相互关联的原型组成的链状结构的就是原型链
- 并非是真的继承，继承意味着复制操作，这里并没有复制对象的属性，只是在两个对象之间创建一个关联，这样一个对象能通过委托访问到另一个对象的属性和函数，与其叫继承，委托的叫法更准确些
- 总结：函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现“继承”，还有一个原型指针__proto__，该指针指向上一层的原型对象，而上一层的原型对象的结构类似，这样利用__proto__一直指向Object的原型对象上，而Object的原型对象用Object.prototype.__proto__ = null表示原型链的最顶端，如此形成了js的原型链继承，也解释了为什么所有的js对象都具有Object的基本方法。

```js
Function.prototype = {
    constructor: Function,
    __proto__:parent.prototype,
    some prototype prototies...
}
```

### this 指向
- this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
- 优先级
  1. 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。
      var bar = new foo()
  2. 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。
      var bar = foo.call(obj2)
  3. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上下文对象。
      var bar = obj1.foo()
  4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。
      var bar = foo()
- this缺陷
  - 嵌套函数中的this不会从外层函数中继承
    - 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
    - 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this
  - 普通函数的this指向window -- 解决方案：严格模式下，this值是undefined
```js
var myObj = {
  name : " 极客时间 ", 
  showThis: function(){
    console.log(this)
    function bar(){console.log(this)}
    bar()
  }
}
myObj.showThis()

// 解决方案： 1 利用另一个变量 self
var myObj = {
  name : " 极客时间 ", 
  showThis: function(){
    console.log(this)
    var self = this
    function bar(){
      self.name = " 极客邦 "
    }
    bar()
  }
}
myObj.showThis()

// 2.箭头函数：因为ES6中的箭头函数并不会创建自身的执行上下文；箭头函数里面的this取决于它的外部函数，通过查找作用域链来确定
var myObj = {
  name : " 极客时间 ", 
  showThis: function(){
    console.log(this)
    var bar = ()=>{
      this.name = " 极客邦 "
      console.log(this)
    }
    bar()
  }
}
```

### 常见运算符/操作符
- instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
- typeof 操作符返回一个字符串，表示未经计算的操作数的类型

