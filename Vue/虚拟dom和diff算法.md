- 最小量更新算法
- 只有是同一个虚拟节点时才拥有最小量更新，否则暴力删除。同一个虚拟节点指的是 选择器sel相同 且 key相同
- 只进行同层比较，跨层暴力删除
- 创建节点时，所有子节点需要递归出来

- 大致流程
    - patch函数被调用  -> oldValue是虚拟节点？ N ->  将oldValue包装成虚拟节点
    - Y  oldVnode和newVnode是同一个节点？ N-> 暴力删除旧的插入新的
    - Y  精细化比较


### Virtual DOM
- 概念：`虚拟DOM就是用JS去按照DOM结构来实现的树形结构对象；一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性`
- 优势：
  - 减少 JavaScript 操作真实 DOM 的带来的性能消耗
  - 抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI
- 过程：
  - `用JS对象模拟DOM（虚拟DOM）`
  - `把此虚拟DOM转成真实DOM并插入页面中（render）createElement，根据 type 生成对应的 DOM，把 data 里定义的 各种属性设置到 DOM 上`
  - `如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）；找到新旧虚拟 DOM 对应的位置，然后进行移动，那么就能够尽量减少 DOM 的操作`
  - `把差异对象应用到真正的DOM树上（patch）`

### Diff
- 头头对比: 对比两个数组的头部，如果找到，把新节点patch到旧节点，头指针后移
- 尾尾对比: 对比两个数组的尾部，如果找到，把新节点patch到旧节点，尾指针前移
- 旧尾新头对比: 交叉对比，旧尾新头，如果找到，把新节点patch到旧节点，旧尾指针前移，新头指针后移
- 旧头新尾对比: 交叉对比，旧头新尾，如果找到，把新节点patch到旧节点，新尾指针前移，旧头指针后移
- 利用key对比: 用新指针对应节点的key去旧数组寻找对应的节点,这里分三种情况,当没有对应的key，那么创建新的节点,如果有key并且是相同的节点，把新节点patch到旧节点,如果有key但是不是相同的节点，则创建新节点

https://blog.csdn.net/wanghuan1020/article/details/112506075