### TCP
TCP/IP 是一类协议系统，它是用于网络通信的一套协议集合．

### TCP三次握手
![tcp握手](./%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)
- `首先server处于listen状态，client 发送 syn，seq=x 到server 发起握手；client处于syn=SENT状态`
- `server 收到 syn后server立马进入SYN-RCVD状态，回复syn+ack给client；`
- `client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack（此时client的48287端口的连接已经是established，server接收到ack后变成established状态）`

### 四次挥手
![tcp挥手](./%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
- `client主动发送fin包给server`
- `server回复ack（对应第一步fin包的ack）给client，表示server知道client要断开了`
- `server发送fin包给client，表示server也可以断开了`
- `client回复ack给server，表示既然双发都发送fin包表示断开，那么就真的断开吧`

- 为什么不是两次握手？
    - 根本原因: 无法确认客户端的接收能力。
    - 分析如下:
        - **如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。**
        - **看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。**
- 凡是需要对端确认的，一定消耗TCP报文的序列号。SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。

- 为什么是四次挥手而不是三次？
    - **因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。**
- 如果是三次挥手会有什么问题？
    - **等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。**

### 为什么握手三次、挥手四次
- 差的一次是在挥手时server分开回复的ack 和 fin，而握手server是一次性回复 syn和ack；之所以绝大数时候我们看到的都是四次挥手，是因为收到fin后，知道对方要关闭了，然后OS通知应用层要关闭啥的，`这里应用层可能需要做些准备工作，有一些延时，所以先回ack，准备好了再发fin； 握手过程没有这个准备过程所以可以立即发送syn+ack。`
- TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。`当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，`我无法了解“上层的意志”
- 总结：握手三次挥手四次都是为了提供`可靠传输`

[详细文档](https://juejin.im/post/6844903685563105293)
![tcp握手挥手](../assets/tcp.jpg)

### 传输层
- 传输层提供了两种到达目标网络的方式
  - 传输控制协议（TCP）：`提供了完善的错误控制和流量控制，能够确保数据正常传输`，`是一个面向连接的协议`。
  - 用户数据报协议（UDP）：只提供了基本的错误检测，`是一个无连接的协议`。
- UDP：
  - 把数据打包
  - 数据大小有限制（64k）
  - `采用无连接`
  - `速度快，但可靠性低`
- TCP：
  - 数据大小无限制
  - `面向连接`
  - `速度慢，但是可靠性高（因为tcp数据包里面有序列号，提供了可靠性）`
  - `建立连接通道，TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）`
  - 拓展：
    - 发送端和接收端的缓冲区大小，通过缓冲区的大小来判断是否可以接受或者发送，流量控制底层是通过滑动窗口实现的
    - 拥塞控制是为了解决网络拥塞情况，主要由四个算法实现：慢启动、拥塞避免、快速重传（丢包需要快速重传）、快速恢复（丢包后另一方调整自己的发送速率）

## 网络体系结构
- 五层协议： 应用层、运输层、网络层、数据链路层、物理层
- `TCP/IP四层体系结构：应用层、传输层、网络层、数据链路层`
- 详解各层作用：
  - `应用层：直接为用户应用进程提供服务。应用层协议：http、dns、支持电子邮件的SMTP协议`
  - `运输层：负责两个主机间的进程通信。运输层协议： 传输控制协议tcp、用户数据包协议`
  - `网络层：把运输层产生的报文段或者数据报封装成分组或包进行传输。网络层协议：IP协议`
  - `数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻结点之间传送帧中的数据`
  - 物理层：透明的传输比特流
