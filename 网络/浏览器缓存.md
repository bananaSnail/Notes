- [缓存机制匹配流程](https://github.com/xiangxingchen/blog/issues/9)
  - `浏览器发送请求前，`根据请求头的`expires`和`cache-control判断是否命中（包括是否过期）强缓存策略`，`如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。`
  - `没有命中强缓存规则，浏览器会发送请求，`根据请求头的`last-modified`和`etag判断是否命中协商缓存`，`如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。`
  - `如果前两步都没有命中，则直接从服务端获取资源。`

- 浏览器http缓存机制：
  - `强缓存会优于协商缓存，若强缓存生效，则直接不发送请求，使用本地资源；不生效接着进行协商缓存。`
  - `协商缓存由服务器判断，若文件失效则返回新资源，否则返回304，不返回资源。`
  - `强弱缓存之间的主要区别在于获取资源时是否会发送请求`
  - 强缓存的 http状态码是 200 OK；协商缓存的 http 状态码是 304 Not Modified
  - 在请求头上添加了max-age=0指令，表示不使用强缓存，但允许协商缓存  max-age优先级大于expires
  - ETag 是请求资源在服务器的唯一标识，浏览器可以根据 ETag 值缓存数据。在再次请求时通过If-None-Match携带上次的 ETag 值，如果值不变，则返回 304，如果改变你则返回新的内容。
  - etag和last modify分别什么优点缺点，适合什么场景【描述】【举例】


缓存头部 | 优点  | 缺点 | 使用场景
---|--- | --- | ---
etag | 不存在版本问题，每次都会跟服务器校验，符合则304不返回资源，不符合则重新返回资源；可以更加精确的判断资源是否被修改；可以识别一秒内资源被多次修改的情况 |  计算tag会造成一定的性能损耗；分布式存储的情况下，保证eta算法的一致性 | etag适合重要量小的资源
last-modified | 不存在版本问题，每次都会跟服务器校验，符合则304不返回资源，不符合则重新返回资源 | 以时刻作为标识符，精确到秒，无法识别一秒内的多次修改；只要资源被修改，无论是否发生实质性的变化，都会将该资源返回给客户端 | last modify适合不重要的量大的资源

![浏览器缓存](assets/浏览器缓存?imageslim)

### 深入了解web浏览器
- https://xie.infoq.cn/article/eede3e411bde101bdf0366ea8
- https://xie.infoq.cn/article/02b0a659aa7cea565a11f4489
- https://xie.infoq.cn/article/e1fe295a68fdf41129a31c421
- https://xie.infoq.cn/article/0d700b848bf0bac6b734efd00