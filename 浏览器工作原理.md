### 垃圾回收机制
- ESP指针：记录调用栈当前执行状态的指针
- 当一个函数执行结束后，JavaScript引擎会通过想下移动ESP来销毁该函数保存在调用栈中的执行上下文，但是该执行上下文中存在堆中的数据此时并没有销毁
- V8把堆分为新生代和老生代两个区域，新生代存放的是生存时间短的对象，老生代中存放生存时间久的对象；副垃圾回收器主要负责回收新生代的垃圾回收，主垃圾回收器主要负责老生代的垃圾回收
- 工作流程：
  - 第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
  - 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
  - 第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

### V8执行JavaScript代码
- V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码
![avatar](/js/assets/v8.png)

### 浏览器事件循环机制
- 事件循环机制：
  - 所有同步任务都在主线程上执行，形成一个执行栈。
  - 主线程之外，还存在一个`任务队列`（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
  - 一旦`执行栈`中的所有同步任务执行完毕，系统就会读取`任务队列`，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
  - 主线程不断重复上面的第三步。
  - 补充：异步任务细分为宏任务和微任务，`微任务优先级高于宏任务，所以微任务会先进入执行栈，然后再是宏任务进入执行栈，如此循环`
- 微任务：Process.nextTick、`Promise.then catch finally`、MutationObserver、async/await
![event loop](/js/assets/eventLoop.png)
