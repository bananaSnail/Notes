### nodejs事件循环、工作池
- 包含两个线程：
    - 事件循环线程（主循环、主线程、事件线程等）
        - 事件循环线程执行事件的回调函数，并且负责对处理类似网络 I/O 的非阻塞异步请求。
    - 工作线程池里的 k 个工作线程（也被称为线程池）
        - 工作线程池来处理“高成本”的任务。 这包括一些操作系统并没有提供非阻塞版本的 I/O 操作，以及一些 CPU 密集型的任务。
        - 在许多 Node.js 应用程序中，这些 API 是工作线程池任务的唯一来源。此外应用程序和模块可以使用 C++ 插件 向工作线程池提交其它任务。
    - 事件循环线程本身并不维护队列，它持有一堆要求操作系统去监听的文件描述符。当操作系统确定某个文件的描述符发生变化，事件轮询线程将把它转换成合适的事件，然后触发与该事件对应的回调函数。
    - 工作线程池则使用一个真实的队列，里边装的都是要被处理的任务。 一个工作线程从这个队列中取出一个任务，开始处理它。当完成之后这个工作线程向事件循环线程中发出一个“至少有一个任务完成了”的消息。
- 阻塞事件循环：
    - nodejs核心模块，如crypto加密、zlib压缩、fs文件系统、child_process子进程
    - JSON系列化，JSON.parse 以及 JSON.stringify 是其它潜在高开销的操作。 这些操作的复杂度是 O(n) ，对于大型的 n 输入，消耗的时间可能惊人的长。
- 避免复杂计算阻塞事件循环
    - 任务拆分：你可以把你的复杂计算 拆分开，然后让每个计算分别运行在事件循环中，不过你要定期地让其它一些等待的事件执行就会。 在 JavaScript 中，用闭包很容易实现保存执行的上下文
    - 任务分流：对一个复杂的任务，最好把它从事件循环线程转移到工作线程池上。
- node work theads
    - 您可以创建和管理自己专用于计算的工作线程池，而不是使用 Node.js 自带的负责的 I/O 的工作线程池。最直接的方法就是使用 Child Process 或者是 cluster。
### (node 事件循环机制：事件循环机制由宿主环境实现)[https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/]
- Nodejs 的事件循环有多个阶段，其中有一个专门处理 I/O 回调的阶段，每一个执行阶段我们可以称之为 Tick ， 每一个 Tick 都会查询是否还有事件以及关联的回调函数 ，如上异步 I/O 的回调函数，会在 I/O 处理阶段检查当前 I/O 是否完成，如果完成，那么执行对应的 I/O 回调函数。在 Nodejs 中，对应观察者接收对应类型的事件，事件循环过程中，会向这些观察者询问有没有该执行的任务，如果有，那么观察者会取出任务，交给事件循环去执行。
- 事件循环阶段：每一个event loop都会包含按如下顺序六个循环阶段
    - timers 阶段: 这个阶段执行 setTimeout(callback) 和 setInterval(callback) 预定的 callback;
    - pending callback ，大部分 I/O 回调任务都是在 poll 阶段执行的，为了调用之前事件循环延迟执行的 I/O 回调函数。
    - idle prepare 阶段: 仅node内部使用;
    - poll 轮询阶段，这个阶段主要做两件事，一这个阶段会执行异步 I/O 的回调函数；二 计算当前轮询阶段阻塞后续阶段的时间。
    - check 阶段: 执行 setImmediate() 设定的callbacks;
    - close callbacks 阶段: 比如 socket.on(‘close’, callback) 的callback会在这个阶段执行;
![node event loop](node事件循环.jpeg)

### 进程线程区别：
- **进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；**
- **线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；**线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。
- **一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。**
- **进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。**
- **进程是资源分配的最小单位，线程是CPU调度的最小单位；**
- **进程切换的开销也远大于线程切换的开销。**


### 如何读取超大型文件
- 使用fs.readFile()一次性将文件内容全部读取出来，考虑到可能将来会操作几G大的文件，所以放弃了这种方式；
- 使用fs.createReadStream()创建一个读文件流，这种方式可不受限于文件的大小；
    - 缺陷：逐行读取，若文件是一行的大型文件则要想办法处理
```js
var fs = require("fs");
var path = require("path");
var readline = require("readline");
const readliner = readline.createInterface({
    input: fs.createReadStream(path.join(__dirname, './filename')),
});
 
readliner.on('line', function(chunk) {
	//处理每一行数据
});
 
readliner.on('close', function() {
	//文件读取结束
});
```

### open和readFile直接读取的区别
- fs.readFile：异步的读取或者写入api，指定编码和读取文件，整个读取出来。即fs.readFile这种异步api不需要fs.open去打开文件，
- fs.read同步api需要配合fs.open，先打开文件，再按buffer流去读取数据，可以控制读取的文件内容长度。
- 一般很少用同步api，大部分情况下都是用异步api操作文件系统
### [node如何实现异步，异步机制](https://www.zybuluo.com/frank-shaw/note/488651ß)
- 阻塞/非阻塞：所谓阻塞和非阻塞是指进程或者线程在进行操作或者数据读写的时候，是否需要等待，在等待的过程中能否进行其他的操作。
- 异步/同步：是指访问数据的方式，同步是指需要主动读取数据，这个读取过程可能是阻塞或者是非阻塞的。而异步是指并不需要主动去读取数据，是被动的通知。
- 事件循环（event loop）：在进程启动的时候，Node就会创建一个循环，每执行一次循环体的过程称为Tick。事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求都是事件的生产者，这些时间被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。