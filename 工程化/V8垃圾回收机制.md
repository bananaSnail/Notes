### 垃圾回收机制
- ESP指针：记录调用栈当前执行状态的指针
- 当一个函数执行结束后，JavaScript引擎会通过想下移动ESP来销毁该函数保存在调用栈中的执行上下文，但是该执行上下文中存在堆中的数据此时并没有销毁
- V8把堆分为新生代和老生代两个区域，新生代存放的是生存时间短的对象，老生代中存放生存时间久的对象；副垃圾回收器主要负责回收新生代的垃圾回收，主垃圾回收器主要负责老生代的垃圾回收
- 工作流程：
  - 第一步是`标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象`。
  - 第二步是`回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。`
  - 第三步是`做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片`，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。
## V8内存结构
- 新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。
- 老生代(old_space)：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。
- 大对象区(large_object_space)：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。
- 代码区(code_space)：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。
- map区(map_space)：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。
### 对象晋升
- 当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为晋升。
- 晋升条件
    - 对象是否经历过一次Scavenge算法
    - To空间的内存占比是否已经超过25%

## 如何避免内存泄露
- 尽可能少地创建全局变量
- 手动清除定时器
- 少用闭包
- 清除DOM引用
- 弱引用：在ES6中为我们新增了两个有效的数据结构WeakMap和WeakSet  -- 弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存